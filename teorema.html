<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Teorema da Entropia Democrática</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
h1 { text-align: center; color: #2c3e50; }
h2, h3 { color: #34495e; }
.formula { background: #ecf0f1; padding: 10px; border-left: 5px solid #3498db; margin: 10px 0; font-family: monospace; }
.simulation { margin: 20px 0; }
input { padding: 8px; margin: 5px; }
canvas { max-width: 100%; height: 300px; margin-bottom: 30px; }
.license, .license-initial { text-align: center; margin-top: 20px; font-size: 0.9em; color: #666; }
@media (max-width: 600px) { .container { padding: 10px; } canvas { height: 200px; } }
</style>
</head>
<body>
<div class="container">
<h1>Teorema da Entropia Democrática</h1>
<div class="license-initial">
<p>© Lara Raquel Rodrigues Branco Arsénio, 2025. Licenciado sob <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Inclui Chart.js (<a href="https://github.com/chartjs/Chart.js/blob/master/LICENSE">MIT License</a>).</p>
</div>

<h2>Resumo</h2>
<p>A democracia em larga escala é um sistema estruturalmente limitado que converge para resultados medíocres, devido à qualidade do voto coletivo, aqui quantificada pela variável Qualidade de Vida (Q), que traduz, de forma abstrata e independente de contextos regionais (Europa, Centro, Desenvolvimento), o objetivo de melhoria global da qualidade de vida. A pressão por coesão grupal conduz as decisões coletivas ao mínimo denominador comum (MDC), comprometendo Q, que estabiliza em valores medianos (~50 numa escala de 0 a 100). Quanto maior a escala (n), isto é, o número de votantes, mais restritivos são os resultados, com entropia absoluta (estabilização de Q com desvio SD(Q) ≤ 1) a partir de um ponto crítico identificado dinamicamente. Simulações em JavaScript validam esta disfuncionalidade em populações numerosas, como a União Europeia (n = 500M). A disfuncionalidade é agravada por vulnerabilidades sistémicas, como intrusão, corrupção, governos sombra e lobbies desregulados. Este teorema demonstra a impossibilidade matemática de alcançar resultados ótimos em larga escala, sugerindo a necessidade de reduzir a escala ou adotar sistemas alternativos.</p>

<h2>Definições</h2>
<p><strong>Qualidade de Vida (Q):</strong> Índice em [0, 100], inspirado no Índice de Desenvolvimento Humano (IDH), abrangendo saúde, educação e rendimento. Exemplo: Q = 100 representa condições ideais; Q = 0 indica ausência de qualidade.</p>
<p><strong>Mínimo Denominador Comum (MDC):</strong> Decisão coletiva, modelada como a mediana das preferências individuais (p* = median(p_i, ..., p_n)), onde p_i ∈ [0, 1] representa a preferência de cada votante. É a escolha mais consensual, mas subótima.</p>
<p><strong>Entropia:</strong> Estagnação de Q em valores medianos (~50), com perda de potencial para decisões que maximizem Q &gt; 60.</p>
<p><strong>Escala (n):</strong> Número de votantes. O ponto de ruptura ocorre onde a variabilidade de Q é insignificante.</p>

<h2>Enunciado</h2>
<p>Nos sistemas democráticos majoritários, a pressão por coesão faz com que as decisões coletivas convirjam para o mínimo denominador comum, subotimizando Q. Para grandes valores de n, Q estabiliza em ~50, com entropia absoluta onde a variabilidade de Q é insignificante. Esta limitação estrutural torna matematicamente impossível alcançar decisões que otimizem Q.</p>

<h2>Fórmulas Matemáticas</h2>
<div class="formula">
Fórmula da Entropia Democrática:<br>
Q_n = 100 &times; med(p_1, p_2, …, p_n)<br>
&sigma;(Q_n) = 50 / (&radic;&mu; &radic;n)
</div>

<h2>Simulação</h2>
<div class="simulation">
<label>Tamanho da Amostra (n): <input type="number" id="sampleSize" value="100" min="1" max="1000"></label><br>
<label>Proporção Populacional (&micro;): <input type="number" id="populationProp" value="0.5" min="0.01" max="0.99" step="0.01"></label>
<p id="result"></p>
</div>

<h2>Gráficos</h2>
<canvas id="histogramChart"></canvas>
<canvas id="distributionChart"></canvas>

<div class="license">
<p>© Lara Raquel Rodrigues Branco Arsénio (CC BY-SA 4.0)</p>
</div>
</div>

<script>
// ---------------- Código original Teorema-v2 ----------------
let histogramChart, normalChart;

function randomNormal(mean,stdDev){
  const u1=Math.random(), u2=Math.random();
  const z=Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
  return mean+stdDev*z;
}

function median(values){
  values.sort((a,b)=>a-b);
  const half=Math.floor(values.length/2);
  return values.length%2 ? values[half] : (values[half-1]+values[half])/2;
}

function fMu(mu){ return Math.sqrt(mu); }

function createHistogramData(values, binSize){
  const bins=Array(20).fill(0);
  values.forEach(val=>{
    const binIndex=Math.min(Math.floor(val/binSize),19);
    bins[binIndex]++;
  });
  return bins;
}

function generateNormalCurve(mean,stdDev,minX,maxX,numPoints){
  const step=(maxX-minX)/(numPoints-1);
  const xValues=Array.from({length:numPoints},(_,i)=>minX+i*step);
  const yValues=xValues.map(x=>(1/(stdDev*Math.sqrt(2*Math.PI)))*Math.exp(-0.5*Math.pow((x-mean)/stdDev,2)));
  return { x:xValues, y:yValues };
}

document.addEventListener('DOMContentLoaded', function(){
  if(typeof Chart==='undefined'){ console.error('Chart.js não carregado'); return; }

  const histogramCanvas=document.getElementById('histogramChart');
  const normalCanvas=document.getElementById('distributionChart');
  if(!histogramCanvas || !normalCanvas){ console.error('Canvas não encontrado'); return; }

  const n=parseInt(document.getElementById('sampleSize').value)||100;
  const mu=parseFloat(document.getElementById('populationProp').value)||0.5;
  const numSims=1000;
  const qnValues=[];

  for(let i=0;i<numSims;i++){
    const props=[];
    for(let j=0;j<n;j++){
      let pi=randomNormal(0.5,0.2);
      pi=Math.min(Math.max(pi,0),1);
      props.push(pi);
    }
    const qn=100*median(props);
    qnValues.push(qn);
  }

  const meanQn=qnValues.reduce((a,b)=>a+b,0)/numSims;
  const varianceQn=qnValues.reduce((a,b)=>a+Math.pow(b-meanQn,2),0)/numSims;
  const stdDevQn=Math.sqrt(varianceQn);
  const theoreticalStdDev=50/(fMu(mu)*Math.sqrt(n));
  const relativeError=theoreticalStdDev>0 ? Math.abs(stdDevQn-theoreticalStdDev)/theoreticalStdDev*100 : 0;

  document.getElementById('result').innerHTML=`
    <strong>Resultados:</strong><br>
    Média de Q_n: ${meanQn.toFixed(2)}<br>
    Desvio Padrão Simulado: ${stdDevQn.toFixed(2)}<br>
    Desvio Padrão Teórico: ${theoreticalStdDev.toFixed(2)}<br>
    Erro Relativo: ${relativeError.toFixed(2)}%
  `;

  const histogramCtx=histogramCanvas.getContext('2d');
  if(histogramChart) histogramChart.destroy();
  const histData={
    labels:Array.from({length:20},(_,i)=>i*5),
    datasets:[{
      label:'Distribuição de Q_n',
      data:createHistogramData(qnValues,5),
      backgroundColor:'rgba(54, 162, 235, 0.5)',
      borderColor:'rgba(54, 162, 235, 1)',
      borderWidth:1
    }]
  };
  histogramChart=new Chart(histogramCtx,{type:'bar',data:histData,options:{scales:{y:{beginAtZero:true},x:{title:{display:true,text:'Q_n'}}}}});

  const normalCtx=normalCanvas.getContext('2d');
  if(normalChart) normalChart.destroy();
  const normalCurve=generateNormalCurve(100*mu,theoreticalStdDev,0,100,100);
  const normalData={
    labels:normalCurve.x,
    datasets:[{
      label:'Distribuição Normal Teórica',
      data:normalCurve.y,
      borderColor:'rgba(255, 99, 132, 1)',
      backgroundColor:'rgba(255, 99, 132, 0.2)',
      fill:true,
      tension:0.4
    }]
  };
  normalChart=new Chart(normalCtx,{type:'line',data:normalData,options:{scales:{y:{beginAtZero:true},x:{title:{display:true,text:'Q_n'}}}}});

  // ---------------- Gráfico dinâmico de n_crit ----------------
  (function(){
    const container=document.querySelector('.container');
    const canvas=document.createElement('canvas');
    container.appendChild(canvas);

    function simulateQn(n,numSims){
      const qnValues=[];
      for(let i=0;i<numSims;i++){
        const props=Array.from({length:n},()=>Math.min(Math.max(Math.random(),0),1));
        qnValues.push(100*median(props));
      }
      const mean=qnValues.reduce((a,b)=>a+b,0)/numSims;
      const sd=Math.sqrt(qnValues.reduce((a,b)=>a+Math.pow(b-mean,2),0)/numSims);
      return { mean, sd };
    }

    const nValues=[];
    for(let n=10;n<=100000;n=n<100?n+10:n<1000?n+50:n<10000?n+500:n+5000) nValues.push(n);

    const sdData=[];
    let nCrit=null;
    nValues.forEach(n=>{
      const { sd }=simulateQn(n,300);
      sdData.push(sd);
      if(nCrit===null && sd<=1) nCrit=n;
    });

    new Chart(canvas.getContext('2d'),{
      type:'line',
      data:{
        labels:nValues,
        datasets:[
          { label:'SD(Q_n)', data:sdData, borderColor:'purple', fill:false, tension:0.2, pointRadius:0 },
          { label:'Limite SD=1', data:Array(nValues.length).fill(1), borderColor:'black', borderDash:[5,5], fill:false, pointRadius:0 },
          { label:'Ponto n_crit', data:sdData.map((v,i)=>i===sdData.findIndex(x=>x<=1)?v:null), borderColor:'red', backgroundColor:'red', pointRadius:8, showLine:false }
        ]
      },
      options:{
        responsive:true,
        plugins:{
          tooltip:{
            callbacks:{
              label:function(ctx){
                if(ctx.dataset.label==='Ponto n_crit'){
                  return `n_crit=${nCrit}, SD(Q_n)=${ctx.raw.toFixed(3)}`;
                }
                return `${ctx.dataset.label}: ${ctx.raw.toFixed(3)}`;
              }
            }
          },
          legend:{display:true, position:'top'}
        },
        scales:{
          x:{title:{display:true,text:'Tamanho da Amostra n'}, type:'log', ticks:{callback: val=>Number(val)}},
          y:{title:{display:true,text:'SD(Q_n)'}, min:0}
        }
      }
    });
  })();

});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Teorema da Entropia Democrática</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body { font-family: Arial, sans-serif; margin:20px; background:#f4f4f4; color:#333; }
.container { max-width: 1000px; margin:auto; background:white; padding:20px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.1);}
h1,h2,h3 { color:#2c3e50; }
.formula { background:#ecf0f1; padding:10px; border-left:5px solid #3498db; font-family: monospace; margin:10px 0;}
canvas { width:100%; height:450px; margin-top:20px; }
.license { text-align:center; font-size:0.9em; margin-top:20px; color:#666; }
label { display:block; margin:10px 0; }
</style>
</head>
<body>
<div class="container">
<h1>Teorema da Entropia Democrática</h1>

<div class="license">
<p>© Lara Raquel Rodrigues Branco Arsénio, 2025. Licenciado sob <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Inclui Chart.js (<a href="https://github.com/chartjs/Chart.js/blob/master/LICENSE">MIT License</a>).</p>
</div>

<h2>Resumo</h2>
<p>A democracia em larga escala tende a resultados medianos devido à agregação por mediana. O Teorema da Entropia Democrática formaliza matematicamente esta limitação estrutural, mostrando que quanto maior a população, menor a dispersão de Q_n, surgindo um ponto de entropia.</p>

<h2>Definições</h2>
<p><strong>Qualidade de Vida (Q):</strong> índice em [0,100], inspirado no IDH, refletindo saúde, educação e rendimento.</p>
<p><strong>Mínimo Denominador Comum (MDC):</strong> decisão coletiva, modelada como a mediana das preferências individuais p_i ∈ [0,1].</p>
<p><strong>Entropia:</strong> estabilização de Q_n em torno de 50, com SD(Q_n) ≈ 0.</p>
<p><strong>Escala (n):</strong> número de votantes. Ponto crítico onde a variabilidade de Q_n se torna insignificante.</p>

<h2>Enunciado</h2>
<p>Em sistemas democráticos majoritários, a pressão por coesão leva decisões coletivas à mediana das preferências individuais, subotimizando Q. À medida que n aumenta, Q_n estabiliza em ~50, atingindo entropia absoluta.</p>

<h2>Fórmula Matemática</h2>
<div class="formula">
Q<sub>n</sub> = 100 &times; med(p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>n</sub>)<br>
σ(Q<sub>n</sub>) = 50 / (&radic;&mu; &radic;n;)
</div>

<h2>Simulação Interativa</h2>
<label>Distribuição de preferências: 
<select id="distType">
  <option value="normal">Normal (µ=0.5, σ=0.2)</option>
  <option value="uniform">Uniforme [0,1]</option>
  <option value="beta">Beta (2,5)</option>
</select>
</label>

<canvas id="entropyChart"></canvas>
<h2>Cálculo do Ponto de Entropia (n_crit)</h2>
<div class="formula">
n<sub>crit</sub> = menor n tal que SD(Q<sub>n</sub>) ≤ 1
</div>
<p>O gráfico abaixo mostra SD(Q<sub>n</sub>) em função de n. A linha preta tracejada indica o limiar de entropia (SD=1) e o ponto roxo mostra o n<sub>crit</sub>.</p>

<canvas id="entropyPointChart"></canvas>

<div class="license">
<p>© Lara Raquel Rodrigues Branco Arsénio (CC BY-SA 4.0)</p>
</div>
</div>

<script>
// Funções matemáticas
function randomNormal(mean=0.5,stdDev=0.2){
    const u1=Math.random(), u2=Math.random();
    const z=Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
    return mean+stdDev*z;
}
function randomUniform(){ return Math.random(); }
function randomBeta(a,b){
    let u=Math.random();
    return Math.pow(u,1/a)/(Math.pow(u,1/a)+Math.pow(1-u,1/b));
}
function median(values){
    values.sort((a,b)=>a-b);
    const half=Math.floor(values.length/2);
    return values.length%2 ? values[half] : (values[half-1]+values[half])/2;
}
function simulateQn(n,sims,distType){
    const results=[];
    for(let s=0;s<sims;s++){
        const props=[];
        for(let j=0;j<n;j++){
            let pi;
            if(distType==='normal'){ pi=Math.min(Math.max(randomNormal(),0),1);}
            else if(distType==='uniform'){ pi=randomUniform();}
            else if(distType==='beta'){ pi=Math.min(Math.max(randomBeta(2,5),0),1);}
            props.push(pi);
        }
        results.push(100*median(props));
    }
    return results;
}

// Configurações
const sampleSizes=[100,5000,20000,100000];
const simsPerN=100;
const colors=['blue','green','orange','red'];
let chart=null;

// Função para criar/atualizar gráfico
function updateChart(){
    const distType=document.getElementById('distType').value;
    const labels=Array.from({length:simsPerN},(_,i)=>i+1);
    const datasets=[];

    sampleSizes.forEach((n,idx)=>{
        const qValues=simulateQn(n,simsPerN,distType);
        const meanQ=qValues.reduce((a,b)=>a+b,0)/qValues.length;
        const sdQ=Math.sqrt(qValues.reduce((a,b)=>a+Math.pow(b-meanQ,2),0)/qValues.length);

        datasets.push({
            label:`n=${n} (média)`,
            data:Array(simsPerN).fill(meanQ),
            borderColor:colors[idx],
            fill:false,
            tension:0.2,
            pointRadius:0
        });

        datasets.push({
            label:`n=${n} (±SD)`,
            data:Array(simsPerN).fill(meanQ+sdQ),
            borderColor:'transparent',
            backgroundColor:colors[idx]+'33',
            fill:'+1',
            pointRadius:0
        });
    });

    datasets.push({
        label:'Ponto de entropia (50)',
        data:Array(simsPerN).fill(50),
        borderColor:'black',
        borderDash:[5,5],
        fill:false,
        pointRadius:0
    });

    if(chart) chart.destroy();
    const ctx=document.getElementById('entropyChart').getContext('2d');
    chart=new Chart(ctx,{
        type:'line',
        data:{labels:labels,datasets:datasets},
        options:{
            responsive:true,
            plugins:{tooltip:{enabled:true,mode:'index',intersect:false},legend:{display:true,position:'top'}},
            scales:{x:{title:{display:true,text:'Replicação'}},y:{title:{display:true,text:'Q_n'},min:0,max:100}}
        }
    });
}
// --- Novo cálculo n_crit com anotação visual ---
function updateEntropyPointChart(){
    const distType=document.getElementById('distType').value;
    const nValues=[100,500,1000,5000,20000,100000];
    const simsPerN=500;
    const sdData=[];

    nValues.forEach(n=>{
        const qSamples=simulateQn(n,simsPerN,distType);
        const meanQ=qSamples.reduce((a,b)=>a+b,0)/qSamples.length;
        const sdQ=Math.sqrt(qSamples.reduce((a,b)=>a+Math.pow(b-meanQ,2),0)/qSamples.length);
        sdData.push(sdQ);
    });

    const threshold=1;
    const nCrit=nValues.find((n,i)=>sdData[i]<=threshold);
    const nCritIndex=nValues.indexOf(nCrit);

    const ctx=document.getElementById('entropyPointChart').getContext('2d');
    if(window.entropyChart) window.entropyChart.destroy();
    window.entropyChart=new Chart(ctx,{
        type:'line',
        data:{
            labels:nValues,
            datasets:[
                {
                    label:'SD(Q_n)',
                    data:sdData,
                    borderColor:'purple',
                    fill:false,
                    tension:0.2,
                    pointRadius:5
                },
                {
                    label:'Limiar de entropia (SD=1)',
                    data:Array(nValues.length).fill(threshold),
                    borderColor:'black',
                    borderDash:[5,5],
                    fill:false,
                    pointRadius:0
                },
                {
                    label:'Ponto de entropia n_crit',
                    data:sdData.map((v,i)=>i===nCritIndex?v:null),
                    borderColor:'red',
                    backgroundColor:'red',
                    pointRadius:8,
                    showLine:false
                }
            ]
        },
        options:{
            responsive:true,
            plugins:{
                tooltip:{
                    enabled:true,
                    callbacks:{
                        label:function(context){
                            if(context.dataset.label==='Ponto de entropia n_crit'){
                                return `n_crit = ${nCrit}, SD(Q_n)=${context.raw.toFixed(3)}`;
                            }
                            return `${context.dataset.label}: ${context.raw.toFixed(3)}`;
                        }
                    }
                },
                legend:{display:true, position:'top'}
            },
            scales:{
                x:{title:{display:true,text:'Tamanho da Amostra n'}, type:'log', ticks:{callback: function(val){return Number(val);}}},
                y:{title:{display:true,text:'SD(Q_n)'}, min:0}
            }
        }
    });

    console.log("Ponto de entropia aproximado n_crit:", nCrit);
}
function updateAllCharts(){
    updateChart();
    updateEntropyPointChart();
}

// Inicialização
updateAllCharts();
document.getElementById('distType').addEventListener('change', updateAllCharts);
</script>
</body>
</html>

<!doctype html>
<html lang="pt-PT">
<head>
  <!-- Encoding rigoroso: UTF-8 explícito (duplicado para compatibilidade) -->
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TED — Mitigação por Megavotos</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { --maxw: 980px; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
           margin: 2rem; color:#111; max-width: var(--maxw); }
    h1,h2,h3 { color:#222; margin: 1.2rem 0 0.5rem; }
    p { margin: 0.6rem 0; }
    canvas { max-width:100%; margin: 1rem 0 1.6rem; }
    pre { background:#f4f4f4; padding:1rem; border-radius:8px; line-height:1.35;
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Noto Sans Mono", "DejaVu Sans Mono", monospace;
          font-size:0.95rem; overflow:auto; }
    .muted { color:#555; font-size:0.95rem; }
    hr { border:0; border-top:1px solid #e5e7eb; margin:1.6rem 0; }
  </style>
</head>
<body>

<h1>Teorema da Entropia Democrática — Mitigação por Megavotos</h1>
<p class="muted"><em>Autora: Lara Raquel Rodrigues Branco Arsénio</em></p>

<p>Teorema (forma base):</p>
<pre>
Qₙ = 100 × med(p₁,…,pₙ)
σ(Qₙ) = 50 / ( f(μ) √n )
ncrit ≈ ( 50 / f(μ) )²
</pre>

<p>Mitigação proposta: agrupar cada 1000 votos num <strong>megavoto</strong>. A mediana local por bloco aproxima μ; o output fica discretizado (0/1 no binário; uma única opção no caso de três opções). A redução de variabilidade segue a lei 1/√n do teorema, mas com perda de granularidade.</p>

<hr>

<h2>Cenário A — Binário (Sim/Não)</h2>
<p>Cada bloco de 1000 votos com probabilidade média <code>p</code> de “Sim” produz um megavoto: 1 se a maioria do bloco for “Sim”, 0 caso contrário (empates → “Não”).</p>

<pre id="consoleBinary">
⇥ Consola (resultados calculados no browser)
</pre>

<canvas id="binaryMeans"></canvas>
<canvas id="binaryStd"></canvas>

<hr>

<h2>Cenário B — Três opções (A, B, C)</h2>
<p>Cada bloco de 1000 votos elege a opção mais votada (empates resolvidos por prioridade local A > B > C).</p>

<pre id="consoleThree">
⇥ Consola (resultados calculados no browser)
</pre>

<canvas id="threeFreqs"></canvas>
<canvas id="threeRelation"></canvas>

<hr>

<p class="muted">Notas: cálculos feitos no cliente (JS) com aproximações estatísticas para desempenho. Gráficos interativos com Chart.js; texto matemático em Unicode UTF-8 (sem entidades).</p>

<script>
/* ============================
   Utilidades numéricas (sem libs)
   ============================ */
function randn() { // Box–Muller
  let u=0,v=0; while(!u) u=Math.random(); while(!v) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function erf(x){ // Abramowitz–Stegun
  const s = x>=0?1:-1; x=Math.abs(x);
  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
  const t=1/(1+p*x);
  const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
  return s*y;
}
function Phi(x){ return 0.5*(1+erf(x/Math.SQRT2)); } // CDF normal padrão

/* Binomial aproximado rápido (normal com arredondamento/recorte) */
function rbinomApprox(n,p){
  const m=n*p, sd=Math.sqrt(n*p*(1-p));
  let x = Math.round(m + sd*randn());
  if (x<0) x=0; if (x>n) x=n;
  return x;
}

/* Multinomial via dois binomiais sequenciais exactos por construção */
function rmultinomApprox(n, probs){ // probs = [pa,pb,pc], pa+pb+pc = 1
  const [pa,pb,pc] = probs;
  const a = rbinomApprox(n, pa);
  const b = rbinomApprox(n - a, pb / (1 - pa));
  const c = n - a - b;
  return [a,b,c];
}

/* ============================
   Parâmetros
   ============================ */
const nBlock = 1000;
const trialsBinary = 4000;
const trialsThree  = 2000;

/* ============================
   Cenário A — Binário
   ============================ */
function Pmegavoto_theory(p){
  // Aproximação normal para P(Qₙ ≥ 0.5)
  const z = (0.5 - p)/Math.sqrt(p*(1-p)/nBlock);
  return 1 - Phi(z);
}

function runBinary(){
  const ps = [0.30, 0.50, 0.70];
  const out = [];
  const meansInd = [];
  const meansMega = [];
  const stdInd = [];
  const stdMega = [];

  for (const p of ps){
    // estatísticas teóricas para proporção no bloco
    const sdProp = Math.sqrt(p*(1-p)/nBlock);
    const pi = Pmegavoto_theory(p); // prob. megavoto=1
    meansInd.push(p);
    meansMega.push(pi);
    stdInd.push(sdProp);
    stdMega.push(Math.sqrt(pi*(1-pi)));
    out.push(
      `p = ${p.toFixed(2)}\n` +
      `  Qₙ: E[proporção] = ${p.toFixed(5)}, σ(Qₙ) ≈ ${sdProp.toFixed(5)}\n` +
      `  P(megavoto=1) ≈ ${pi.toFixed(5)}  → σ(megavoto) ≈ ${Math.sqrt(pi*(1-pi)).toFixed(5)}\n`
    );
  }

  // consola
  document.getElementById('consoleBinary').textContent =
`>>> n = ${nBlock}
>>> cenários p = [${ps.join(', ')}]

${out.join('\n')}`.trim();

  // Gráfico 1: médias individuais vs megavotos
  new Chart(document.getElementById('binaryMeans'), {
    type: 'bar',
    data: {
      labels: ps.map(p=>`p=${p}`),
      datasets: [
        { label:'Média individuais (Sim)', data: meansInd,
          backgroundColor:'rgba(54,162,235,0.6)' },
        { label:'Frequência megavotos (Sim)', data: meansMega,
          backgroundColor:'rgba(255,99,132,0.6)' }
      ]
    },
    options: {
      responsive:true,
      plugins:{ title:{display:true, text:'Sim: individual vs megavoto (n=1000)'},
                tooltip:{mode:'index', intersect:false} },
      scales:{ y:{ beginAtZero:true, max:1 } }
    }
  });

  // Gráfico 2: desvios padrão comparados
  new Chart(document.getElementById('binaryStd'), {
    type: 'bar',
    data: {
      labels: ps.map(p=>`p=${p}`),
      datasets: [
        { label:'σ proporções (Qₙ)', data: stdInd,
          backgroundColor:'rgba(75,192,192,0.6)' },
        { label:'σ megavoto (Bernoulli)', data: stdMega,
          backgroundColor:'rgba(255,206,86,0.6)' }
      ]
    },
    options: {
      responsive:true,
      plugins:{ title:{display:true, text:'Variabilidade: Qₙ vs megavoto (n=1000)'} },
      scales:{ y:{ beginAtZero:true } }
    }
  });
}

/* ============================
   Cenário B — Três opções
   ============================ */
function runThree(){
  const sets = [
    [0.40, 0.35, 0.25],
    [0.34, 0.33, 0.33],
    [0.60, 0.25, 0.15]
  ];

  const freqs = []; // por conjunto: [fA,fB,fC]
  const logLines = [];

  for (const probs of sets){
    let wA=0,wB=0,wC=0;
    let mA=0,mB=0,mC=0;
    for (let t=0; t<trialsThree; t++){
      const [a,b,c] = rmultinomApprox(nBlock, probs);
      mA += a; mB += b; mC += c;
      // vencedor com desempate A > B > C
      let win = 0; // A
      if (b > a && b >= c) win = 1;
      else if (c > a && c > b) win = 2;
      if (win===0) wA++; else if (win===1) wB++; else wC++;
    }
    const fA = wA/trialsThree, fB = wB/trialsThree, fC = wC/trialsThree;
    const meanA = mA/(trialsThree*nBlock), meanB = mB/(trialsThree*nBlock), meanC = mC/(trialsThree*nBlock);
    freqs.push([fA,fB,fC]);
    logLines.push(
      `probs = [${probs.map(x=>x.toFixed(2)).join(', ')}]\n` +
      `  média individual  : A=${meanA.toFixed(5)}, B=${meanB.toFixed(5)}, C=${meanC.toFixed(5)}\n` +
      `  megavotos venced.: A=${fA.toFixed(5)}, B=${fB.toFixed(5)}, C=${fC.toFixed(5)}\n`
    );
  }

  // consola
  document.getElementById('consoleThree').textContent =
`>>> n = ${nBlock}
>>> blocos (simulação) = ${trialsThree}

${logLines.join('\n')}`.trim();

  // Gráfico 1: frequência de vitórias por conjunto
  new Chart(document.getElementById('threeFreqs'), {
    type:'bar',
    data:{
      labels:['A','B','C'],
      datasets: freqs.map((f,i)=>({
        label:`probs=${sets[i].map(x=>x.toFixed(2)).join('/')}`,
        data:f,
        backgroundColor: i===0 ? 'rgba(54,162,235,0.6)' :
                         i===1 ? 'rgba(255,99,132,0.6)' :
                                 'rgba(255,206,86,0.6)'
      }))
    },
    options:{
      responsive:true,
      plugins:{ title:{display:true, text:'Frequência de vitórias por megavoto (A/B/C)'} },
      scales:{ y:{ beginAtZero:true, max:1 } }
    }
  });

  // Gráfico 2: relação suporte(A) vs sucesso(A)
  const gridA = [0.30,0.35,0.40,0.45,0.50,0.55,0.60];
  const pts = [];
  for (const pa of gridA){
    const pb = (1-pa)/2, pc = pb;
    let winsA=0;
    const T = 800; // blocos por ponto (leve)
    for (let t=0; t<T; t++){
      const [a,b,c] = rmultinomApprox(nBlock, [pa,pb,pc]);
      let win = 0;
      if (b > a && b >= c) win = 1;
      else if (c > a && c > b) win = 2;
      if (win===0) winsA++;
    }
    pts.push({x:pa, y:winsA/T});
  }

  new Chart(document.getElementById('threeRelation'), {
    type:'line',
    data:{
      labels: gridA,
      datasets:[{
        label:'Taxa de sucesso de A (megavoto)',
        data: pts.map(p=>p.y),
        borderColor:'rgba(54,162,235,1)',
        backgroundColor:'rgba(54,162,235,0.2)',
        fill:true
      }]
    },
    options:{
      responsive:true,
      plugins:{ title:{display:true, text:'Suporte individual de A vs sucesso em megavotos (B=C)'} },
      scales:{ x:{ title:{display:true, text:'suporte médio individual de A'} },
               y:{ title:{display:true, text:'fração de megavotos que elegem A'}, beginAtZero:true, max:1 } }
    }
  });
}

/* Run */
runBinary();
runThree();
</script>

</body>
</html>

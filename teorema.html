<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teorema da Entropia Democrática</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 800px; margin: auto; min-height:100%;background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #2c3e50; }
        h2 { color: #34495e; }
        h3 { color: #34495e; }
        .formula { background: #ecf0f1; padding: 10px; border-left: 5px solid #3498db; margin: 10px 0; font-family: monospace; }
        .simulation { margin: 20px 0; }
        input { padding: 8px; margin: 5px; }
        canvas { max-width: 100%; height: 300px; }
        .license { text-align: center; margin-top: 20px; font-size: 0.9em; color: #666; }
        .license-initial { text-align: center; margin-bottom: 20px; font-size: 0.9em; color: #666; }
        @media (max-width: 600px) { .container { padding: 10px; } canvas { height: 200px; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Teorema da Entropia Democrática</h1>
        <div class="license-initial">
            <p>© Lara Raquel Rodrigues Branco Arsénio, 2025. Licenciado sob <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Inclui Chart.js (<a href="https://github.com/chartjs/Chart.js/blob/master/LICENSE">MIT License</a>).</p>
        </div>
        
        <h2>Resumo</h2>
        <p>A democracia em larga escala é um sistema estruturalmente limitado que converge para resultados medíocres, devido à qualidade do voto coletivo, aqui quantificada pela variável Qualidade de Vida (Q), que traduz, de forma abstrata e independente de contextos regionais (Europa, Centro, Desenvolvimento), o objetivo de melhoria global da qualidade de vida. A pressão por coesão grupal conduz as decisões coletivas ao mínimo denominador comum (MDC), comprometendo Q, que estabiliza em valores medianos (~50 numa escala de 0 a 100). Quanto maior a escala (n), isto é, o número de votantes, mais restritivos são os resultados, com entropia absoluta (estabilização de Q com desvio SD(Q) ≤ 1) a partir de um ponto crítico identificado dinamicamente. Simulações em JavaScript validam esta disfuncionalidade em populações numerosas, como a União Europeia (n = 500M). A disfuncionalidade é agravada por vulnerabilidades sistémicas, como intrusão, corrupção, governos sombra e lobbies desregulados. Este teorema demonstra a impossibilidade matemática de alcançar resultados ótimos em larga escala, sugerindo a necessidade de reduzir a escala ou adotar sistemas alternativos.</p>
        
        <h2>Definições</h2>
        <p><strong>Qualidade de Vida (Q):</strong> Índice em [0, 100], inspirado no Índice de Desenvolvimento Humano (IDH), abrangendo saúde, educação e rendimento. Exemplo: Q = 100 representa condições ideais; Q = 0 indica ausência de qualidade.</p>
        <p><strong>Mínimo Denominador Comum (MDC):</strong> Decisão coletiva, modelada como a mediana das preferências individuais (p* = median(p_i, ..., p_n)), onde p_i ∈ [0, 1] representa a preferência de cada votante. É a escolha mais consensual, mas subótima.</p>
        <p><strong>Entropia:</strong> Estagnação de Q em valores medianos (~50), com perda de potencial para decisões que maximizem Q > 60.</p>
        <p><strong>Escala (n):</strong> Número de votantes. O ponto de ruptura ocorre onde a variabilidade de Q é insignificante.</p>
        
        <h2>Enunciado</h2>
        <p>Nos sistemas democráticos majoritários, a pressão por coesão faz com que as decisões coletivas convirjam para o mínimo denominador comum, subotimizando Q. Para grandes valores de n, Q estabiliza em ~50, com entropia absoluta onde a variabilidade de Q é insignificante. Esta limitação estrutural torna matematicamente impossível alcançar decisões que otimizem Q.</p>
        
        <h2>Fórmulas Matemáticas</h2>
        <div class="formula">
            Fórmula da Entropia Democrática:<br>
           <p>
        Q<sub>n</sub> = 100 &cdot; med(p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>n</sub>), 
        &sigma;(Q<sub>n</sub>) = 50 / (f(&mu;) &radic;n)
           </p>
        </div>
        
        <h2>Modelo</h2>
        <h3>Hipóteses</h3>
        <p>Preferências individuais p_i ∈ [0, 1] seguem uma distribuição normal (média 0.5, desvio padrão 0.2).<br>
        Decisão coletiva: p* = median(p_i, ..., p_n).<br>
        Qualidade de vida: Q = p* × 100.<br>
        Entropia absoluta: SD(Q) ≤ 1, ou seja, Q ∈ [48, 52] em 95% do tempo.</p>
        
        <h2>Simulação</h2>
        <div class="license">
            <p>© Lara Raquel Rodrigues Branco Arsénio (CC BY-SA 4.0)</p>
        </div>
 
<h1>Animação da Entropia Democrática</h1>
<canvas id="entropyComparisonChart"></canvas>
<p id="currentN"></p>
<script>
document.addEventListener('DOMContentLoaded', function(){

    const container = document.body;

    // Criar canvas se não existir
    let canvas = document.getElementById('entropyComparisonChart');
    if(!canvas){
        canvas = document.createElement('canvas');
        canvas.id = 'entropyComparisonChart';
        canvas.style.maxWidth = '900px';
        canvas.style.height = '450px';
        container.appendChild(canvas);
    }

    const ctx = canvas.getContext('2d');

    // Funções matemáticas
    function randomNormal(mean, stdDev){
        const u1 = Math.random();
        const u2 = Math.random();
        const z = Math.sqrt(-2*Math.log(u1)) * Math.cos(2*Math.PI*u2);
        return mean + stdDev*z;
    }

    function median(values){
        values.sort((a,b)=>a-b);
        const half = Math.floor(values.length/2);
        return values.length%2 ? values[half] : (values[half-1]+values[half])/2;
    }

    function simulateQn(n, sims){
        const results = [];
        for(let s=0; s<sims; s++){
            const props = [];
            for(let j=0; j<n; j++){
                let pi = randomNormal(0.5,0.2);
                pi = Math.min(Math.max(pi,0),1);
                props.push(pi);
            }
            results.push(100*median(props));
        }
        return results;
    }

    // Parâmetros
    const sampleSizes = [100, 5000, 20000, 100000]; // diferentes n
    const simsPerN = 100; // número de replicações
    const colors = ['blue','green','orange','red'];

    const chartData = {
        labels: Array.from({length:simsPerN}, (_,i)=>i+1),
        datasets: []
    };

    sampleSizes.forEach((n, idx) => {
        const qValues = simulateQn(n,simsPerN);
        chartData.datasets.push({
            label: `n = ${n}`,
            data: qValues,
            borderColor: colors[idx],
            fill:false,
            tension:0.2,
            pointRadius:2
        });
    });

    // Linha horizontal ponto de entropia (50)
    chartData.datasets.push({
        label: 'Ponto de entropia (50)',
        data: Array(simsPerN).fill(50),
        borderColor: 'black',
        borderDash:[5,5],
        fill:false,
        pointRadius:0
    });

    // Inicializar gráfico
    new Chart(ctx,{
        type:'line',
        data: chartData,
        options:{
            responsive:true,
            plugins:{
                tooltip:{enabled:true, mode:'index', intersect:false},
                legend:{display:true, position:'top'}
            },
            scales:{
                x:{ title:{display:true,text:'Replicação'} },
                y:{ title:{display:true,text:'Q_n'}, min:0, max:100 }
            }
        }
    });

});
    // --- Bloco adicional para n_crit ---
(function(){
  // Criar canvas dinamicamente dentro do container existente
  const container = document.querySelector('.container');
  const canvas = document.createElement('canvas');
  container.appendChild(canvas);

  // Funções auxiliares
  function median(arr){
    const sorted=[...arr].sort((a,b)=>a-b);
    const mid=Math.floor(sorted.length/2);
    return arr.length%2===0 ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];
  }

  function simulateQn(n,numSims){
    const qnValues=[];
    for(let i=0;i<numSims;i++){
      const props=Array.from({length:n},()=>Math.min(Math.max(Math.random(),0),1));
      qnValues.push(100*median(props));
    }
    const mean=qnValues.reduce((a,b)=>a+b,0)/numSims;
    const sd=Math.sqrt(qnValues.reduce((a,b)=>a+Math.pow(b-mean,2),0)/numSims);
    return { mean, sd };
  }

  // Simular SD(Q_n) para vários n
  const nValues=[];
  for(let n=10; n<=100000; n=n<100? n+10 : n<1000? n+50 : n<10000? n+500 : n+5000){
    nValues.push(n);
  }

  const sdData=[];
  let nCrit=null;
  nValues.forEach(n=>{
    const { sd }=simulateQn(n,300);
    sdData.push(sd);
    if(nCrit===null && sd<=1) nCrit=n;
  });

  // Criar gráfico
  new Chart(canvas.getContext('2d'),{
    type:'line',
    data:{
      labels:nValues,
      datasets:[
        { label:'SD(Q_n)', data:sdData, borderColor:'purple', fill:false, tension:0.2, pointRadius:0 },
        { label:'Limite SD=1', data:Array(nValues.length).fill(1), borderColor:'black', borderDash:[5,5], fill:false, pointRadius:0 },
        { label:'Ponto n_crit', data:sdData.map((v,i)=>i===sdData.findIndex(x=>x<=1)?v:null), borderColor:'red', backgroundColor:'red', pointRadius:8, showLine:false }
      ]
    },
    options:{
      responsive:true,
      plugins:{
        tooltip:{
          callbacks:{
            label:function(ctx){
              if(ctx.dataset.label==='Ponto n_crit'){
                return `n_crit=${nCrit}, SD(Q_n)=${ctx.raw.toFixed(3)}`;
              }
              return `${ctx.dataset.label}: ${ctx.raw.toFixed(3)}`;
            }
          }
        },
        legend:{display:true, position:'top'}
      },
      scales:{
        x:{title:{display:true,text:'Tamanho da Amostra n'}, type:'log', ticks:{callback: val=>Number(val)}},
        y:{title:{display:true,text:'SD(Q_n)'}, min:0}
      }
    }
  });
})();

</script>



</body>
</html>

        
    

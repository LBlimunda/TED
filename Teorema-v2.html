<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teorema da Entropia Democrática</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 800px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #2c3e50; }
        h2 { color: #34495e; }
        h3 { color: #34495e; }
        .formula { background: #ecf0f1; padding: 10px; border-left: 5px solid #3498db; margin: 10px 0; font-family: monospace; }
        .simulation { margin: 20px 0; }
        input { padding: 8px; margin: 5px; }
        canvas { max-width: 100%; height: 300px; }
        .license { text-align: center; margin-top: 20px; font-size: 0.9em; color: #666; }
        .license-initial { text-align: center; margin-bottom: 20px; font-size: 0.9em; color: #666; }
        @media (max-width: 600px) { .container { padding: 10px; } canvas { height: 200px; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Teorema da Entropia Democrática</h1>
        <div class="license-initial">
            <p>© Lara Raquel Rodrigues Branco Arsénio, 2025. Licenciado sob <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Inclui Chart.js (<a href="https://github.com/chartjs/Chart.js/blob/master/LICENSE">MIT License</a>).</p>
        </div>
        
        <h2>Resumo</h2>
        <p>A democracia em larga escala é um sistema estruturalmente limitado que converge para resultados medíocres, devido à qualidade do voto coletivo, aqui quantificada pela variável Qualidade de Vida (Q), que traduz, de forma abstrata e independente de contextos regionais (Europa, Centro, Desenvolvimento), o objetivo de melhoria global da qualidade de vida. A pressão por coesão grupal conduz as decisões coletivas ao mínimo denominador comum (MDC), comprometendo Q, que estabiliza em valores medianos (~50 numa escala de 0 a 100). Quanto maior a escala (n), isto é, o número de votantes, mais restritivos são os resultados, com entropia absoluta (estabilização de Q com desvio SD(Q) ≤ 1) a partir de um ponto crítico identificado dinamicamente. Simulações em JavaScript validam esta disfuncionalidade em populações numerosas, como a União Europeia (n = 500M). A disfuncionalidade é agravada por vulnerabilidades sistémicas, como intrusão, corrupção, governos sombra e lobbies desregulados. Este teorema demonstra a impossibilidade matemática de alcançar resultados ótimos em larga escala, sugerindo a necessidade de reduzir a escala ou adotar sistemas alternativos.</p>
        
        <h2>Definições</h2>
        <p><strong>Qualidade de Vida (Q):</strong> Índice em [0, 100], inspirado no Índice de Desenvolvimento Humano (IDH), abrangendo saúde, educação e rendimento. Exemplo: Q = 100 representa condições ideais; Q = 0 indica ausência de qualidade.</p>
        <p><strong>Mínimo Denominador Comum (MDC):</strong> Decisão coletiva, modelada como a mediana das preferências individuais (p* = median(p_i, ..., p_n)), onde p_i ∈ [0, 1] representa a preferência de cada votante. É a escolha mais consensual, mas subótima.</p>
        <p><strong>Entropia:</strong> Estagnação de Q em valores medianos (~50), com perda de potencial para decisões que maximizem Q > 60.</p>
        <p><strong>Escala (n):</strong> Número de votantes. O ponto de ruptura ocorre onde a variabilidade de Q é insignificante.</p>
        
        <h2>Enunciado</h2>
        <p>Nos sistemas democráticos majoritários, a pressão por coesão faz com que as decisões coletivas convirjam para o mínimo denominador comum, subotimizando Q. Para grandes valores de n, Q estabiliza em ~50, com entropia absoluta onde a variabilidade de Q é insignificante. Esta limitação estrutural torna matematicamente impossível alcançar decisões que otimizem Q.</p>
        
        <h2>Fórmulas Matemáticas</h2>
        <div class="formula">
            Fórmula da Entropia Democrática:<br>
            \( Q_n = 100 \times \text{med}(p_1, p_2, \dots, p_n) \)<br>
            \( \sigma(Q_n) = \frac{50}{\sqrt{\mu} \sqrt{n}} \)
        </div>
        
        <h2>Modelo</h2>
        <h3>Hipóteses</h3>
        <p>Preferências individuais p_i ∈ [0, 1] seguem uma distribuição normal (média 0.5, desvio padrão 0.2).<br>
        Decisão coletiva: p* = median(p_i, ..., p_n).<br>
        Qualidade de vida: Q = p* × 100.<br>
        Entropia absoluta: SD(Q) ≤ 1, ou seja, Q ∈ [48, 52] em 95% do tempo.</p>
        
        <h2>Simulação</h2>
        <div class="simulation">
            <label>Tamanho da Amostra (n): <input type="number" id="sampleSize" value="100" min="1" max="1000"></label><br>
            <label>Proporção Populacional (μ): <input type="number" id="populationProp" value="0.5" min="0.01" max="0.99" step="0.01"></label>
            <p id="result"></p>
        </div>
        
        <h2>Gráficos</h2>
        <canvas id="histogramChart"></canvas>
        <canvas id="distributionChart"></canvas>
        
        <div class="license">
            <p>© Lara Raquel Rodrigues Branco Arsénio (CC BY-SA 4.0)</p>
        </div>
    </div>
    
    <script>
        // Copyright (c) Lara Raquel Rodrigues Branco Arsénio, 2025
// Licensed under CC BY-SA 4.0: https://creativecommons.org/licenses/by-sa/4.0/
// Inclui Chart.js (MIT License): https://github.com/chartjs/Chart.js/blob/master/LICENSE

// Inicialização dos gráficos
let histogramChart, normalChart;
window.alert('teste js - hello world');
// Função para gerar número aleatório normal (Box-Muller)
function randomNormal(mean, stdDev) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + stdDev * z;
}

// Função para calcular mediana
function median(values) {
    values.sort((a, b) => a - b);
    const half = Math.floor(values.length / 2);
    return values.length % 2 ? values[half] : (values[half - 1] + values[half]) / 2;
}

// Função f(μ) = √μ
function fMu(mu) {
    return Math.sqrt(mu);
}

// Função para criar dados do histograma
function createHistogramData(values, binSize) {
    const bins = Array(20).fill(0); // 20 bins de 0 a 100
    values.forEach(val => {
        const binIndex = Math.min(Math.floor(val / binSize), 19); // Evita overflow
        bins[binIndex]++;
    });
    return bins;
}

// Função para gerar pontos da curva normal
function generateNormalCurve(mean, stdDev, minX, maxX, numPoints) {
    const step = (maxX - minX) / (numPoints - 1);
    const xValues = Array.from({ length: numPoints }, (_, i) => minX + i * step);
    const yValues = xValues.map(
        x => (1 / (stdDev * Math.sqrt(2 * Math.PI))) *
             Math.exp(-0.5 * Math.pow((x - mean) / stdDev, 2))
    );
    return { x: xValues, y: yValues };
}

// Função principal
document.addEventListener('DOMContentLoaded', function() {
    if (typeof Chart === 'undefined') {
        console.error('Chart.js não carregado. Verifique o CDN.');
        return;
    }

    const histogramCanvas = document.getElementById('histogramChart');
    const normalCanvas = document.getElementById('distributionChart');
    if (!histogramCanvas || !normalCanvas) {
        console.error('Canvas não encontrado: histogramChart ou distributionChart ausente.');
        return;
    }

    const n = parseInt(document.getElementById('sampleSize').value) || 100;
    const mu = parseFloat(document.getElementById('populationProp').value) || 0.5;
    const numSims = 1000; // Simulações para o histograma
    const qnValues = [];

    // Gerar simulações para Q_n
    for (let i = 0; i < numSims; i++) {
        let props = [];
        for (let j = 0; j < n; j++) {
            let pi = randomNormal(0.5, 0.2);
            pi = Math.min(Math.max(pi, 0), 1); // Limitar a [0, 1]
            props.push(pi);
        }
        const qn = 100 * median(props);
        qnValues.push(qn);
    }

    // Calcular estatísticas
    const meanQn = qnValues.reduce((a, b) => a + b, 0) / numSims;
    const varianceQn = qnValues.reduce((a, b) => a + Math.pow(b - meanQn, 2), 0) / numSims;
    const stdDevQn = Math.sqrt(varianceQn);
    const theoreticalStdDev = 50 / (fMu(mu) * Math.sqrt(n));
    const relativeError = theoreticalStdDev > 0
        ? Math.abs(stdDevQn - theoreticalStdDev) / theoreticalStdDev * 100
        : 0;

    // Atualizar resultados
    document.getElementById('result').innerHTML = `
        <strong>Resultados:</strong><br>
        Média de Q_n: ${meanQn.toFixed(2)}<br>
        Desvio Padrão Simulado: ${stdDevQn.toFixed(2)}<br>
        Desvio Padrão Teórico: ${theoreticalStdDev.toFixed(2)}<br>
        Erro Relativo: ${relativeError.toFixed(2)}%
    `;

    // Atualizar Histograma
    const histogramCtx = histogramCanvas.getContext('2d');
    if (histogramChart) histogramChart.destroy();
    const histData = {
        labels: Array.from({ length: 20 }, (_, i) => i * 5), // Bins de 0 a 95
        datasets: [{
            label: 'Distribuição de Q_n',
            data: createHistogramData(qnValues, 5),
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
        }]
    };
    histogramChart = new Chart(histogramCtx, {
        type: 'bar',
        data: histData,
        options: {
            scales: {
                y: { beginAtZero: true },
                x: { title: { display: true, text: 'Q_n' } }
            }
        }
    });

    // Atualizar Curva Normal Teórica
    const normalCtx = normalCanvas.getContext('2d');
    if (normalChart) normalChart.destroy();
    const normalCurve = generateNormalCurve(100 * mu, theoreticalStdDev, 0, 100, 100);
    const normalData = {
        datasets: [{
            label: 'Distribuição Normal Teórica',
            data: normalCurve.x.map((x, i) => ({ x, y: normalCurve.y[i] })),
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            fill: true,
            tension: 0.4
        }]
    };
    normalChart = new Chart(normalCtx, {
        type: 'line',
        data: normalData,
        options: {
            scales: {
                x: { type: 'linear', title: { display: true, text: 'Q_n' } },
                y: { beginAtZero: true }
            }
        }
    });
});
    </script>
</body>
</html>
